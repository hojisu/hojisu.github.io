# 자료 구조

## Summary
- 스택은 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out) 형식의 자료 구조
- 큐는 먼저 집어 넣은 데이터가 먼저 나오는 FIFO(First In First Out) 구조로 저장하는 형식


## Array
- 같은 타입의 데이터를 나열한 선형 자료구조
- 연속된 메모리 공간에 순차적으로 저장
- 배열의 크기는 고정. 선언할 때에 배열의 크기를 정하고 변경할 수 없다.
- 시간 복잡도
    - 삽입/삭제
        - 배열의 맨 앞에 삽입/삭제하는 경우 O(n)
        - 배열의 맨 뒤에 삽입/삭제하는 경우 O(1)
        - 배열의 중간에 삽입/삭제하는 경우 O(n)
    - 탐색 O(1)
- 장점
    - 인덱스를 가지고 있어 바로 접근 가능 (시간복잡도 O(1))
        - 자료구조의 크기가 클수록 더 강력
    - 연속된 메모리 공간에 존재하기 때문에 관리가 편하다
- 단점
    - 삽입과 삭제가 어렵고 오래 걸린다.
    - 배열의 크기를 바꿀 수 없다.
    - 연속된 메모리라서 공간 낭비가 발생
    - 연속적인 메모리 할당 필요
- 사용 상황
    - 데이터 개수가 확실하게 정해져 있을 때
    - 데이터의 삭제와 삽입이 적을 때
    - 검색을 해야할 때

## Linked list(리스트)
- 불연속적 메모리 공간에 저장 (데이터를 빈틈 없이 저장)
- 노드를 연결하여 만든 리스트
    - 첫번째 노드를 헤드, 마지막 노드를 테일이라고 함.
    - 각 노드는 데이터와 다음 노드를 가리키는 포인터로 이루어짐
- 크기가 고정되어 있지 않음
- 인덱스 접근이 불가능
- 시간 복잡도
    - **삽입**
        - 리스트의 맨 앞/뒤에 삽입하는 경우 : O(1)
        - 리스트의 중간에 삽입하는 경우 : O(n) (탐색하는 시간)
    - **삭제**- 리스트의 맨 앞/뒤에서 삭제하는 경우 : O(1)
        - 리스트의 중간에서 삭제하는 경우 : O(n)(탐색하는 시간)
    - **탐색** O(n)
- 장점
    - 삽입과 삭제가 용이
- 단점
    - 원소를 탐색할 때 임의 접근 불가능
    - 포인터로 인하여 저장 공간의 낭비
- 사용 상황
    - 데이터 변화가 많은 상황 일 때
    - 크기가 정해져 있지 않을 때
    - 삽입과 삭제가 자주 일어날 때
    - 검색을 자주 하지 않을 때

## Stack
- 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out) 형식의 자료 구조
- 가장 최근에 스택에 추가한 항목이 가장 먼저 제거될 항목이다.
- 사용 상황 : 재귀 알고리즘을 사용하는 경우 유용하다.
    - 재귀적으로 함수를 호출해야 하는 경우에 임시 데이터를 스택에 넣어준다.
    - 재귀함수를 빠져 나와 퇴각 검색을 할 때는 스택에 넣어 두었던 임시 데이터를 빼 줘야 한다.
    - 스택은 이런 일련의 행위를 직관적으로 가능하게 해준다.
    - 실행 취소
    - 역순 문자열 만들기
    - 수식의 괄호 검사 (연산자 우선 순위 표현을 위한 괄호 검사)

## Queue
- 먼저 집어 넣은 데이터가 먼저 나오는 FIFO(First In First Out) 구조로 저장하는 형식
- 사용 상황 : 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용한다.
    - 너비 우선 탐색(BFS, Breadth-First Search) 구현
    - 캐시(Cache) 구현
    - 우선순위가 같은 작업 예약(인쇄 대기열)
    - 선입선출이 필요한 대기열(티켓 카운터)
    - 프로세스 관리

## Hash Table
- 정의 : key-value의 map 자료 구조다. Hash Table은 hash function을 사용하여 index를 버킷(bucket)의 배열로 계산
- 특징 : index를 가져오기 위한 hash function은 해시 충돌(hash collision)이 발생할 수도 있는데, 두 개 이상의 다른 key에 대해 hash function이 같은 index를 리턴하는 것을 의미한다. 이 충돌을 해결하기 위해 linked list를 이용해 구현하곤 한다. 같은 index를 가지는 key-value 쌍을 linked list에 넣고 충돌이 발생할 경우 각 노드를 일일이 비교함으로써 해결 할 수 있다. 따라서 최적화된 hash function을 선택하는 것이 중요하다.
- 시간 복잡도 : 해시 충돌이 발생하지 않는다면 O(1), 최악의 경우 모든 노드를 일일이 비교하며 찾아야 한다면 O(n)
    - O(1)은 loop 돌지 않고 바로 찾는 다는 의미
    - O(n)은 서치 할때 모든 n개의 아이템을 살펴봐야 된다는 의미
- 사용 상황 구분 : 고객을 찾을 때

## Heap
- 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조이다.
- 여러 개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조이다.
- 힙은 일종의 반정렬 상태(느슨한 정렬 상태)를 유지한다.
    - 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨이 있다는 정도
    - 간단히 말하면 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진 트리를 말한다.
- 힙 트리에서는 중복된 값을 허용한다. (이진 탐색 트리에서는 중복된 값을 허용하지 않는다.)

## Tree
- 트리는 노드로 이루어진 자료 구조이다.
- 노드들과 노드들을 연결하는 간선들로 구성되어 있다.
- 트리는 계층 모델이다.
- 트리는 DAG(Directed Acyclic Graphs)의 한 종류이다.
- 길이(length)는 출발 노드에서 목적지 노드까지 거쳐야 하는 가짓수를 의미한다.
- 깊이(Depth)는 루트 노드에서 특정 노드까지의 길이를 의미한다.
- 높이(Height)은 루트 노드에서 가장 깊은 노드까지의 길이이다.

### 이진트리
- 최대 2개의 자식을 가질 수 있는 트리이다.
- 포화 이진 트리(Full Binary Tree)는 리프 노드를 제외한 모든 노드가 두 자식을 가지고 있다.
- 완전 이진 트리(Complete Binary Tree)는 모든 노드들이 왼쪽 자식부터 차근차근 채워진다.
- 높이 균형 트리(Height Balanced Tree)는 왼쪽 자식 트리와 오른쪽 자식 트리의 높이가 1이상 차이나지 않는 트리이다.

#### 이진 트리의 순회
- 전위 순회 : 뿌리 - 왼쪽 자식 - 오른쪽 자식
- 중위 순회 : 왼쪽 자식 - 뿌리 - 오른쪽 자식
- 후위 순회 : 왼쪽 자식 - 오른쪽 자식 - 뿌리 

## Graph
- 노드와 그 노드를 연결하는 간선을 하나로 모아 놓은 자료 구조이다.
- 즉, 연결 되어 있는 객체 간의 관계를 표현할 수 있는 자료 구조이다.
- 그래프는 네트워크 모델이다.
- 루트 노드라는 개념이 없다. 부모-자식 관계라는 개념이 없다.
- 방향 그래프, 무방향 그래프가 있다.

![graph_tree.png](../../../resource/img/graph_tree.png)


Reference
- https://gmlwjd9405.github.io/2017/10/01/basic-concepts-of-development-algorithm.html